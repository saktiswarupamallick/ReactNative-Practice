{"version":3,"file":"contractMessages.js","names":["_appleUtils","data","require","_chalk","_interopRequireDefault","_CommandError","_log","_convertHTMLToASCII","obj","__esModule","default","getContractStatusAsync","context","_capabilities$contrac","capabilities","ITCAgreements","getCapabilitiesAsync","contractStatus","error","Log","warn","message","getContractMessagesAsync","getRequiredContractMessagesAsync","_await$getContractMes2","status","includes","messages","isFatal","_await$getContractMes","newLine","rootUrl","formatContractMessage","convertHTMLToASCII","content","subject","filter","Boolean","join","assertContractMessagesAsync","spinner","Array","isArray","length","stop","log","chalk","yellow","bold","isDebug","JSON","stringify","addNewLineIfNone","CommandError"],"sources":["../../src/appleApi/contractMessages.ts"],"sourcesContent":["import { ITCAgreements, RequestContext } from '@expo/apple-utils';\nimport chalk from 'chalk';\nimport { Ora } from 'ora';\n\nimport CommandError from '../CommandError';\nimport Log from '../log';\nimport { convertHTMLToASCII } from './convertHTMLToASCII';\n\nasync function getContractStatusAsync(\n  context: RequestContext\n): Promise<ITCAgreements.ITCContractStatus | null> {\n  try {\n    const capabilities = await ITCAgreements.getCapabilitiesAsync(context);\n    return capabilities?.contractStatus ?? null;\n  } catch (error: any) {\n    Log.warn(`Failed to get iTunes contract status: ${error.message}`);\n    return null;\n  }\n}\n\nasync function getContractMessagesAsync(context: RequestContext) {\n  try {\n    return await ITCAgreements.getContractMessagesAsync(context);\n  } catch (error: any) {\n    Log.warn(`Failed to get iTunes contract messages: ${error.message}`);\n    return null;\n  }\n}\n\nasync function getRequiredContractMessagesAsync(\n  context: RequestContext\n): Promise<{ messages: ITCAgreements.ITCContractMessage[]; isFatal: boolean }> {\n  // This emulates the check that's performed on the ASC website's \"apps\"\n  // page before presenting the (+) create app button.\n  const status = await getContractStatusAsync(context);\n\n  if (status) {\n    if (['FREE_APP_AGREEMENT_ACTIVE', 'PAID_APP_AGREEMENT_ACTIVE'].includes(status)) {\n      // The user can freely create an app, no contracts need to be accepted.\n      // No need to check for messages because afaict no vital messages will be present.\n      return { messages: [], isFatal: false };\n    } else if (\n      ['FREE_APP_AGREEMENT_OUTDATED', 'PAID_APP_AGREEMENT_OUTDATED', 'EXPIRED_MEMBERSHIP'].includes(\n        status\n      )\n    ) {\n      // The user cannot create an app until they've reviewed, and agreed to the updated agreements\n      // or renewed their membership on ASC.\n      // Get the exact messages from ASC to show the user a useful message.\n      return { messages: (await getContractMessagesAsync(context)) ?? [], isFatal: true };\n    }\n  }\n  // The contract messages aren't documented so if a new one is present we cannot be sure if it's fatal or not.\n  // This will check for messages, if none exist, then the process will continue.\n  // Otherwise messages will be present and the process will stop.\n  // There is a small chance that this could result in a false positive if the messages are extraneous, so we'll also\n  // prompt the user to open an issue so we can address the new contract state if it ever appears.\n  // TODO: Maybe a silent analytic would be better\n  Log.error(\n    `\\nUnexpected Apple developer contract status \"${status}\". Please open an issue on https://github.com/expo/eas-cli`\n  );\n  Log.newLine();\n  return { messages: (await getContractMessagesAsync(context)) ?? [], isFatal: false };\n}\n\nconst rootUrl = 'https://appstoreconnect.apple.com';\n\nexport function formatContractMessage(message: ITCAgreements.ITCContractMessage): string {\n  return convertHTMLToASCII({\n    content:\n      '\\u203A ' +\n      [message.subject && `<b>${message.subject}</b>`, message.message]\n        .filter(Boolean)\n        .join('<br />'),\n    rootUrl,\n  });\n}\n\nexport async function assertContractMessagesAsync(context: RequestContext, spinner?: Ora) {\n  const { messages, isFatal } = await getRequiredContractMessagesAsync(context);\n\n  if (Array.isArray(messages) && messages.length) {\n    if (spinner) {\n      spinner.stop();\n    }\n    Log.newLine();\n    Log.log(chalk.yellow.bold('Messages from App Store Connect:'));\n    Log.newLine();\n    for (const message of messages) {\n      if (Log.isDebug) {\n        Log.log(JSON.stringify(message, null, 2));\n        Log.newLine();\n      }\n      Log.addNewLineIfNone();\n      Log.log(formatContractMessage(message));\n    }\n    Log.addNewLineIfNone();\n    // Only throw an error if we know that the status is fatal, otherwise attempt to finish the process.\n    if (isFatal) {\n      throw new CommandError('App Store Connect has agreement updates that must be resolved');\n    }\n  }\n}\n"],"mappings":"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"}